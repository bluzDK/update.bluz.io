'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _http = require('http');

var _http2 = _interopRequireDefault(_http);

var _https = require('https');

var _https2 = _interopRequireDefault(_https);

var _url = require('url');

var _url2 = _interopRequireDefault(_url);

var _events = require('events');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* eslint max-depth: 0 */


var EventStream = function (_EventEmitter) {
	_inherits(EventStream, _EventEmitter);

	function EventStream(uri, token, options) {
		_classCallCheck(this, EventStream);

		var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(EventStream).call(this));

		_this.uri = uri;
		_this.token = token;
		_this.reconnectInterval = 2000;
		Object.assign(_this, options);
		return _this;
	}

	_createClass(EventStream, [{
		key: 'connect',
		value: function connect() {
			var _this2 = this;

			return new Promise(function (resolve, reject) {
				var _url$parse = _url2.default.parse(_this2.uri);

				var hostname = _url$parse.hostname;
				var protocol = _url$parse.protocol;
				var port = _url$parse.port;
				var path = _url$parse.path;

				_this2.origin = protocol + '//' + hostname + (port ? ':' + port : '');

				var isSecure = protocol === 'https:';
				var requestor = isSecure ? _https2.default : _http2.default;
				var req = requestor.request({
					hostname: hostname,
					protocol: protocol,
					path: path + '?history_limit=30&access_token=' + _this2.token,
					method: 'get',
					port: port || (isSecure ? 443 : 80),
					avoidFetch: true,
					mode: 'prefer-streaming'
				});

				_this2.req = req;
				if (_this2.debug) {
					_this2.debug(_this2);
				}

				req.on('error', function (e) {
					reject({ error: e, errorDescription: 'Network error from ' + _this2.uri });
				});

				req.on('response', function (res) {
					var statusCode = res.statusCode;
					if (statusCode !== 200) {
						var _ret = function () {
							var body = '';
							res.on('data', function (chunk) {
								return body += chunk;
							});
							res.on('end', function () {
								try {
									body = JSON.parse(body);
								} catch (e) {}
								_this2.emit('response', {
									statusCode: statusCode,
									body: body
								});
								var errorDescription = 'HTTP error ' + statusCode + ' from ' + _this2.uri;
								if (body && body.error_description) {
									errorDescription += ' - ' + body.error_description;
								}
								reject({ statusCode: statusCode, errorDescription: errorDescription, body: body });
								_this2.req = undefined;
							});
							return {
								v: undefined
							};
						}();

						if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object") return _ret.v;
					}

					_this2.data = '';
					_this2.buf = '';
					_this2.eventName;
					_this2.lastEventId;

					res.on('data', _this2.parse.bind(_this2));
					res.once('end', _this2.end.bind(_this2));
					resolve(_this2);
				});
				req.end();
			});
		}
	}, {
		key: 'abort',
		value: function abort() {
			if (this.req) {
				this.req.abort();
				this.req = undefined;
			}
			this.removeAllListeners();
		}
	}, {
		key: 'end',
		value: function end() {
			var _this3 = this;

			this.req = undefined;
			setTimeout(function () {
				_this3.connect().catch(function (err) {
					_this3.emit('error', err);
					_this3.removeAllListeners();
				});
			}, this.reconnectInterval);
		}
	}, {
		key: 'parse',
		value: function parse(chunk) {
			this.buf += chunk;
			var pos = 0;
			var length = this.buf.length;
			var discardTrailingNewline = false;

			while (pos < length) {
				if (discardTrailingNewline) {
					if (this.buf[pos] === '\n') {
						++pos;
					}
					discardTrailingNewline = false;
				}

				var lineLength = -1;
				var fieldLength = -1;

				for (var i = pos; lineLength < 0 && i < length; ++i) {
					var c = this.buf[i];
					if (c === ':') {
						if (fieldLength < 0) {
							fieldLength = i - pos;
						}
					} else if (c === '\r') {
						discardTrailingNewline = true;
						lineLength = i - pos;
					} else if (c === '\n') {
						lineLength = i - pos;
					}
				}

				if (lineLength < 0) {
					break;
				}

				this.parseEventStreamLine(pos, fieldLength, lineLength);

				pos += lineLength + 1;
			}

			if (pos === length) {
				this.buf = '';
			} else if (pos > 0) {
				this.buf = this.buf.slice(pos);
			}
		}
	}, {
		key: 'parseEventStreamLine',
		value: function parseEventStreamLine(pos, fieldLength, lineLength) {
			if (lineLength === 0) {
				try {
					if (this.data.length > 0 && this.eventName) {
						var event = JSON.parse(this.data);
						event.name = this.eventName;
						if (this.eventName !== 'event') {
							this.emit(this.eventName, event);
						}
						this.emit('event', event);
						this.data = '';
					}
					this.eventName = undefined;
				} catch (e) {
					// do nothing if JSON.parse fails
				}
			} else if (fieldLength > 0) {
					var field = this.buf.slice(pos, pos + fieldLength);
					var step = 0;

					if (this.buf[pos + fieldLength + 1] !== ' ') {
						step = fieldLength + 1;
					} else {
						step = fieldLength + 2;
					}
					pos += step;
					var valueLength = lineLength - step;
					var value = this.buf.slice(pos, pos + valueLength);

					if (field === 'data') {
						this.data += value + '\n';
					} else if (field === 'event') {
						this.eventName = value;
					} else if (field === 'id') {
						this.lastEventId = value;
					} else if (field === 'retry') {
						var retry = parseInt(value, 10);
						if (!Number.isNaN(retry)) {
							this.reconnectInterval = retry;
						}
					}
				}
		}
	}]);

	return EventStream;
}(_events.EventEmitter);

exports.default = EventStream;
module.exports = exports['default'];
//# sourceMappingURL=EventStream.js.map